description: backwards compatibility for older versions of icu
author: Michael Gilbert <mgilbert@debian.org>

--- a/third_party/blink/renderer/platform/graphics/logging_canvas.cc
+++ b/third_party/blink/renderer/platform/graphics/logging_canvas.cc
@@ -513,8 +513,12 @@ String StringForUTF32LEText(const void*
   utf16 = icu::UnicodeString::fromUTF32(reinterpret_cast<const UChar32*>(text),
                                         static_cast<int32_t>(byte_length));
 #endif
+#if U_ICU_VERSION_MAJOR_NUM >= 59
   return String(icu::toUCharPtr(utf16.getBuffer()),
                 static_cast<unsigned>(utf16.length()));
+#else
+  return String(utf16.getBuffer(),static_cast<unsigned>(utf16.length()));
+#endif
 }
 
 String StringForText(const void* text,
--- a/components/url_formatter/idn_spoof_checker.cc
+++ b/components/url_formatter/idn_spoof_checker.cc
@@ -415,8 +415,8 @@ Skeletons IDNSpoofChecker::GetSkeletons(
   if ((u04cf_pos = host.indexOf(0x4CF)) != -1) {
     icu::UnicodeString host_alt(host);
     size_t length = host_alt.length();
-    char16_t* buffer = host_alt.getBuffer(-1);
-    for (char16_t* uc = buffer + u04cf_pos; uc < buffer + length; ++uc) {
+    UChar* buffer = host_alt.getBuffer(-1);
+    for (UChar* uc = buffer + u04cf_pos; uc < buffer + length; ++uc) {
       if (*uc == 0x4CF)
         *uc = 0x6C;  // Lowercase L
     }
--- a/v8/src/objects/intl-objects.cc
+++ b/v8/src/objects/intl-objects.cc
@@ -36,14 +36,6 @@
 #include "unicode/ustring.h"
 #include "unicode/uvernum.h"  // U_ICU_VERSION_MAJOR_NUM
 
-#define XSTR(s) STR(s)
-#define STR(s) #s
-static_assert(
-    V8_MINIMUM_ICU_VERSION <= U_ICU_VERSION_MAJOR_NUM,
-    "v8 is required to build with ICU " XSTR(V8_MINIMUM_ICU_VERSION) " and up");
-#undef STR
-#undef XSTR
-
 namespace v8 {
 namespace internal {
 
--- a/v8/src/objects/js-locale.cc
+++ b/v8/src/objects/js-locale.cc
@@ -20,7 +20,6 @@
 #include "src/objects-inl.h"
 #include "src/objects/intl-objects.h"
 #include "src/objects/js-locale-inl.h"
-#include "unicode/char16ptr.h"
 #include "unicode/locid.h"
 #include "unicode/uloc.h"
 #include "unicode/unistr.h"
--- a/v8/src/objects/js-list-format.cc
+++ b/v8/src/objects/js-list-format.cc
@@ -278,7 +278,6 @@ MaybeHandle<JSArray> GenerateListFormatP
   Handle<String> substring;
   for (const icu::FieldPosition pos : positions) {
     CHECK(pos.getBeginIndex() >= prev_item_end_index);
-    CHECK(pos.getField() == ULISTFMT_ELEMENT_FIELD);
     if (pos.getBeginIndex() != prev_item_end_index) {
       ASSIGN_RETURN_ON_EXCEPTION(
           isolate, substring,
@@ -316,10 +315,7 @@ std::vector<icu::FieldPosition> Generate
   std::vector<icu::FieldPosition> positions;
   icu::FieldPosition pos;
   while (iter.next(pos)) {
-    // Only take the information of the ULISTFMT_ELEMENT_FIELD field.
-    if (pos.getField() == ULISTFMT_ELEMENT_FIELD) {
       positions.push_back(pos);
-    }
   }
   // Because the format may reoder the items, ICU FieldPositionIterator
   // keep the order for FieldPosition based on the order of the input items.
@@ -435,7 +431,7 @@ MaybeHandle<JSArray> JSListFormat::Forma
   icu::UnicodeString formatted;
   icu::FieldPositionIterator iter;
   formatter->format(array.data(), static_cast<int32_t>(array.size()), formatted,
-                    &iter, status);
+                    status);
   DCHECK(U_SUCCESS(status));
 
   std::vector<icu::FieldPosition> field_positions = GenerateFieldPosition(iter);
--- a/v8/src/regexp/regexp-parser.cc
+++ b/v8/src/regexp/regexp-parser.cc
@@ -1293,11 +1293,9 @@ bool IsSupportedBinaryProperty(UProperty
     case UCHAR_DEPRECATED:
     case UCHAR_DIACRITIC:
     case UCHAR_EMOJI:
-    case UCHAR_EMOJI_COMPONENT:
     case UCHAR_EMOJI_MODIFIER_BASE:
     case UCHAR_EMOJI_MODIFIER:
     case UCHAR_EMOJI_PRESENTATION:
-    case UCHAR_EXTENDED_PICTOGRAPHIC:
     case UCHAR_EXTENDER:
     case UCHAR_GRAPHEME_BASE:
     case UCHAR_GRAPHEME_EXTEND:
@@ -1316,7 +1314,6 @@ bool IsSupportedBinaryProperty(UProperty
     case UCHAR_PATTERN_WHITE_SPACE:
     case UCHAR_QUOTATION_MARK:
     case UCHAR_RADICAL:
-    case UCHAR_REGIONAL_INDICATOR:
     case UCHAR_S_TERM:
     case UCHAR_SOFT_DOTTED:
     case UCHAR_TERMINAL_PUNCTUATION:
