description: maintain compatibility with icu 6.3
author: Michael Gilbert <mgilbert@debian.org>

--- a/v8/src/objects/intl-objects.h
+++ b/v8/src/objects/intl-objects.h
@@ -20,7 +20,7 @@
 #include "unicode/locid.h"
 #include "unicode/uversion.h"
 
-#define V8_MINIMUM_ICU_VERSION 64
+#define V8_MINIMUM_ICU_VERSION 63
 
 namespace U_ICU_NAMESPACE {
 class BreakIterator;
--- a/v8/src/objects/js-list-format.cc
+++ b/v8/src/objects/js-list-format.cc
@@ -254,6 +254,78 @@ Handle<String> JSListFormat::TypeAsStrin
 
 namespace {
 
+// From chromium 74
+std::vector<icu::FieldPosition> GenerateFieldPosition(
+    icu::FieldPositionIterator iter) {
+  std::vector<icu::FieldPosition> positions;
+  icu::FieldPosition pos;
+  while (iter.next(pos)) {
+    // Only take the information of the ULISTFMT_ELEMENT_FIELD field.
+    if (pos.getField() == ULISTFMT_ELEMENT_FIELD) {
+      positions.push_back(pos);
+    }
+  }
+  // Because the format may reoder the items, ICU FieldPositionIterator
+  // keep the order for FieldPosition based on the order of the input items.
+  // But the formatToParts API in ECMA402 expects in formatted output order.
+  // Therefore we have to sort based on beginIndex of the FieldPosition.
+  // Example of such is in the "ur" (Urdu) locale with type: "unit", where the
+  // main text flows from right to left, the formatted list of unit should flow
+  // from left to right and therefore in the memory the formatted result will
+  // put the first item on the last in the result string according the current
+  // CLDR patterns.
+  // See 'listPattern' pattern in
+  // third_party/icu/source/data/locales/ur_IN.txt
+  std::sort(positions.begin(), positions.end(),
+            [](icu::FieldPosition a, icu::FieldPosition b) {
+              return a.getBeginIndex() < b.getBeginIndex();
+            });
+  return positions;
+}
+
+// From chromium 74
+MaybeHandle<JSArray> GenerateListFormatParts(
+    Isolate* isolate, const icu::UnicodeString& formatted,
+    const std::vector<icu::FieldPosition>& positions) {
+  Factory* factory = isolate->factory();
+  Handle<JSArray> array =
+      factory->NewJSArray(static_cast<int>(positions.size()));
+  int index = 0;
+  int prev_item_end_index = 0;
+  Handle<String> substring;
+  for (const icu::FieldPosition pos : positions) {
+    CHECK(pos.getBeginIndex() >= prev_item_end_index);
+    CHECK(pos.getField() == ULISTFMT_ELEMENT_FIELD);
+    if (pos.getBeginIndex() != prev_item_end_index) {
+      ASSIGN_RETURN_ON_EXCEPTION(
+          isolate, substring,
+          Intl::ToString(isolate, formatted, prev_item_end_index,
+                         pos.getBeginIndex()),
+          JSArray);
+      Intl::AddElement(isolate, array, index++, factory->literal_string(),
+                       substring);
+    }
+    ASSIGN_RETURN_ON_EXCEPTION(
+        isolate, substring,
+        Intl::ToString(isolate, formatted, pos.getBeginIndex(),
+                       pos.getEndIndex()),
+        JSArray);
+    Intl::AddElement(isolate, array, index++, factory->element_string(),
+                     substring);
+    prev_item_end_index = pos.getEndIndex();
+  }
+  if (prev_item_end_index != formatted.length()) {
+    ASSIGN_RETURN_ON_EXCEPTION(
+        isolate, substring,
+        Intl::ToString(isolate, formatted, prev_item_end_index,
+                       formatted.length()),
+        JSArray);
+    Intl::AddElement(isolate, array, index++, factory->literal_string(),
+                     substring);
+  }
+  return array;
+}
+
 // Extract String from JSArray into array of UnicodeString
 Maybe<std::vector<icu::UnicodeString>> ToUnicodeStringArray(
     Isolate* isolate, Handle<JSArray> array) {
@@ -296,7 +368,7 @@ Maybe<std::vector<icu::UnicodeString>> T
 template <typename T>
 MaybeHandle<T> FormatListCommon(
     Isolate* isolate, Handle<JSListFormat> format, Handle<JSArray> list,
-    MaybeHandle<T> (*formatToResult)(Isolate*, const icu::FormattedList&)) {
+    MaybeHandle<T> (*formatToResult)(Isolate*, const icu::UnicodeString&, const icu::FieldPositionIterator&)) {
   DCHECK(!list->IsUndefined());
   // ecma402 #sec-createpartsfromlist
   // 2. If list contains any element value such that Type(value) is not String,
@@ -310,23 +382,21 @@ MaybeHandle<T> FormatListCommon(
   CHECK_NOT_NULL(formatter);
 
   UErrorCode status = U_ZERO_ERROR;
-  icu::FormattedList formatted = formatter->formatStringsToValue(
-      array.data(), static_cast<int32_t>(array.size()), status);
+  icu::UnicodeString formatted;
+  icu::FieldPositionIterator iter;
+  formatter->format(array.data(), static_cast<int32_t>(array.size()), formatted,
+                    &iter, status);
   if (U_FAILURE(status)) {
     THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kIcuError), T);
   }
-  return formatToResult(isolate, formatted);
+  return formatToResult(isolate, formatted, iter);
 }
 
 // A helper function to convert the FormattedList to a
 // MaybeHandle<String> for the implementation of format.
 MaybeHandle<String> FormattedToString(Isolate* isolate,
-                                      const icu::FormattedList& formatted) {
-  UErrorCode status = U_ZERO_ERROR;
-  icu::UnicodeString result = formatted.toString(status);
-  if (U_FAILURE(status)) {
-    THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kIcuError), String);
-  }
+                                      const icu::UnicodeString& result,
+                                      const icu::FieldPositionIterator& iter) {
   return Intl::ToString(isolate, result);
 }
 
@@ -346,27 +416,10 @@ Handle<String> IcuFieldIdToType(Isolate*
 // A helper function to convert the FormattedList to a
 // MaybeHandle<JSArray> for the implementation of formatToParts.
 MaybeHandle<JSArray> FormattedToJSArray(Isolate* isolate,
-                                        const icu::FormattedList& formatted) {
-  Handle<JSArray> array = isolate->factory()->NewJSArray(0);
-  icu::ConstrainedFieldPosition cfpos;
-  cfpos.constrainCategory(UFIELD_CATEGORY_LIST);
-  int index = 0;
-  UErrorCode status = U_ZERO_ERROR;
-  icu::UnicodeString string = formatted.toString(status);
-  Handle<String> substring;
-  while (formatted.nextPosition(cfpos, status) && U_SUCCESS(status)) {
-    ASSIGN_RETURN_ON_EXCEPTION(
-        isolate, substring,
-        Intl::ToString(isolate, string, cfpos.getStart(), cfpos.getLimit()),
-        JSArray);
-    Intl::AddElement(isolate, array, index++,
-                     IcuFieldIdToType(isolate, cfpos.getField()), substring);
-  }
-  if (U_FAILURE(status)) {
-    THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kIcuError), JSArray);
-  }
-  JSObject::ValidateElements(*array);
-  return array;
+                                      const icu::UnicodeString& formatted,
+                                      const icu::FieldPositionIterator& iter) {
+  std::vector<icu::FieldPosition> field_positions = GenerateFieldPosition(iter);
+  return GenerateListFormatParts(isolate, formatted, field_positions);
 }
 
 }  // namespace
--- a/v8/src/objects/js-relative-time-format.cc
+++ b/v8/src/objects/js-relative-time-format.cc
@@ -212,6 +212,65 @@ Handle<String> JSRelativeTimeFormat::Num
 
 namespace {
 
+// From chromium 74
+MaybeHandle<JSArray> GenerateRelativeTimeFormatParts(
+    Isolate* isolate, const icu::UnicodeString& formatted,
+    const icu::UnicodeString& integer_part, const Handle<String>& unit,
+    double number, const icu::NumberFormat& nf) {
+  Factory* factory = isolate->factory();
+  Handle<JSArray> array = factory->NewJSArray(0);
+  int32_t found = formatted.indexOf(integer_part);
+
+  Handle<String> substring;
+  if (found < 0) {
+    // Cannot find the integer_part in the formatted.
+    // Return [{'type': 'literal', 'value': formatted}]
+    ASSIGN_RETURN_ON_EXCEPTION(isolate, substring,
+                               Intl::ToString(isolate, formatted), JSArray);
+    Intl::AddElement(isolate, array,
+                     0,                          // index
+                     factory->literal_string(),  // field_type_string
+                     substring);
+  } else {
+    // Found the formatted integer in the result.
+    int index = 0;
+
+    // array.push({
+    //     'type': 'literal',
+    //     'value': formatted.substring(0, found)})
+    if (found > 0) {
+      ASSIGN_RETURN_ON_EXCEPTION(isolate, substring,
+                                 Intl::ToString(isolate, formatted, 0, found),
+                                 JSArray);
+      Intl::AddElement(isolate, array, index++,
+                       factory->literal_string(),  // field_type_string
+                       substring);
+    }
+
+    Handle<Object> number_obj = factory->NewNumber(number);
+    Maybe<int> maybe_format_to_parts = JSNumberFormat::FormatToParts(
+        isolate, array, index, nf, number_obj, unit);
+    MAYBE_RETURN(maybe_format_to_parts, Handle<JSArray>());
+    index = maybe_format_to_parts.FromJust();
+
+    // array.push({
+    //     'type': 'literal',
+    //     'value': formatted.substring(
+    //         found + integer_part.length, formatted.length)})
+    if (found + integer_part.length() < formatted.length()) {
+      ASSIGN_RETURN_ON_EXCEPTION(
+          isolate, substring,
+          Intl::ToString(isolate, formatted, found + integer_part.length(),
+                         formatted.length()),
+          JSArray);
+      Intl::AddElement(isolate, array, index,
+                       factory->literal_string(),  // field_type_string
+                       substring);
+    }
+  }
+  return array;
+}
+
 Handle<String> UnitAsString(Isolate* isolate, URelativeDateTimeUnit unit_enum) {
   Factory* factory = isolate->factory();
   switch (unit_enum) {
@@ -274,7 +333,8 @@ MaybeHandle<T> FormatCommon(
     Isolate* isolate, Handle<JSRelativeTimeFormat> format,
     Handle<Object> value_obj, Handle<Object> unit_obj, const char* func_name,
     MaybeHandle<T> (*formatToResult)(Isolate*,
-                                     const icu::FormattedRelativeDateTime&,
+                                     const icu::UnicodeString&,
+                                     const icu::NumberFormat&,
                                      Handle<Object>, Handle<String>)) {
   // 3. Let value be ? ToNumber(value).
   Handle<Object> value;
@@ -304,26 +364,27 @@ MaybeHandle<T> FormatCommon(
                       unit),
         T);
   }
+
   UErrorCode status = U_ZERO_ERROR;
-  icu::FormattedRelativeDateTime formatted =
-      (format->numeric() == JSRelativeTimeFormat::Numeric::ALWAYS)
-          ? formatter->formatNumericToValue(number, unit_enum, status)
-          : formatter->formatToValue(number, unit_enum, status);
+  icu::UnicodeString formatted;
+
+  if (format->numeric() == JSRelativeTimeFormat::Numeric::ALWAYS) {
+    formatter->formatNumeric(number, unit_enum, formatted, status);
+  } else {
+    DCHECK_EQ(JSRelativeTimeFormat::Numeric::AUTO, format->numeric());
+    formatter->format(number, unit_enum, formatted, status);
+  }
+
   if (U_FAILURE(status)) {
     THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kIcuError), T);
   }
-  return formatToResult(isolate, formatted, value,
+  return formatToResult(isolate, formatted, formatter->getNumberFormat(), value,
                         UnitAsString(isolate, unit_enum));
 }
 
 MaybeHandle<String> FormatToString(
-    Isolate* isolate, const icu::FormattedRelativeDateTime& formatted,
-    Handle<Object> value, Handle<String> unit) {
-  UErrorCode status = U_ZERO_ERROR;
-  icu::UnicodeString result = formatted.toString(status);
-  if (U_FAILURE(status)) {
-    THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kIcuError), String);
-  }
+    Isolate* isolate, const icu::UnicodeString& result,
+    const icu::NumberFormat& nf, Handle<Object> value, Handle<String> unit) {
   return Intl::ToString(isolate, result);
 }
 
@@ -354,67 +415,26 @@ Maybe<bool> AddUnit(Isolate* isolate, Ha
 }
 
 MaybeHandle<JSArray> FormatToJSArray(
-    Isolate* isolate, const icu::FormattedRelativeDateTime& formatted,
-    Handle<Object> value, Handle<String> unit) {
+    Isolate* isolate, const icu::UnicodeString& formatted,
+    const icu::NumberFormat& nf, Handle<Object> value, Handle<String> unit) {
   UErrorCode status = U_ZERO_ERROR;
-  icu::UnicodeString string = formatted.toString(status);
-
-  Factory* factory = isolate->factory();
-  Handle<JSArray> array = factory->NewJSArray(0);
-  icu::ConstrainedFieldPosition cfpos;
-  cfpos.constrainCategory(UFIELD_CATEGORY_NUMBER);
-  int32_t index = 0;
-
-  int32_t previous_end = 0;
-  Handle<String> substring;
-  std::vector<std::pair<int32_t, int32_t>> groups;
-  while (formatted.nextPosition(cfpos, status) && U_SUCCESS(status)) {
-    int32_t category = cfpos.getCategory();
-    int32_t field = cfpos.getField();
-    int32_t start = cfpos.getStart();
-    int32_t limit = cfpos.getLimit();
-    if (category == UFIELD_CATEGORY_NUMBER) {
-      if (field == UNUM_GROUPING_SEPARATOR_FIELD) {
-        groups.push_back(std::pair<int32_t, int32_t>(start, limit));
-        continue;
-      }
-      if (start > previous_end) {
-        Maybe<bool> maybe_added =
-            AddLiteral(isolate, array, string, index++, previous_end, start);
-        MAYBE_RETURN(maybe_added, Handle<JSArray>());
-      }
-      if (field == UNUM_INTEGER_FIELD) {
-        for (auto start_limit : groups) {
-          if (start_limit.first > start) {
-            Maybe<bool> maybe_added =
-                AddUnit(isolate, array, string, index++, start,
-                        start_limit.first, field, value, unit);
-            MAYBE_RETURN(maybe_added, Handle<JSArray>());
-            maybe_added = AddUnit(isolate, array, string, index++,
-                                  start_limit.first, start_limit.second,
-                                  UNUM_GROUPING_SEPARATOR_FIELD, value, unit);
-            MAYBE_RETURN(maybe_added, Handle<JSArray>());
-            start = start_limit.second;
-          }
-        }
-      }
-      Maybe<bool> maybe_added = AddUnit(isolate, array, string, index++, start,
-                                        limit, field, value, unit);
-      MAYBE_RETURN(maybe_added, Handle<JSArray>());
-      previous_end = limit;
-    }
-  }
-  if (U_FAILURE(status)) {
-    THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kIcuError), JSArray);
-  }
-  if (string.length() > previous_end) {
-    Maybe<bool> maybe_added = AddLiteral(isolate, array, string, index,
-                                         previous_end, string.length());
-    MAYBE_RETURN(maybe_added, Handle<JSArray>());
+  icu::UnicodeString number_str;
+  icu::FieldPosition pos;
+  double number = value->Number();
+  double abs_number = std::abs(number);
+  nf.format(abs_number, number_str, pos, status);
+    if (U_FAILURE(status)) {
+    THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kIcuError),
+                    JSArray);
   }
 
-  JSObject::ValidateElements(*array);
-  return array;
+  Handle<JSArray> elements;
+  ASSIGN_RETURN_ON_EXCEPTION(isolate, elements,
+                             GenerateRelativeTimeFormatParts(
+                                 isolate, formatted, number_str, unit,
+                                 abs_number, nf),
+                             JSArray);
+  return elements;
 }
 
 }  // namespace
